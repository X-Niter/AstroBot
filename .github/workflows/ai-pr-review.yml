name: AI Pull Request Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: false
        type: number
      review_all:
        description: 'Review all open PRs'
        required: false
        default: 'false'
        type: boolean

jobs:
  review-pr:
    name: AI Code Review
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install openai black pylint mypy pytest pytest-cov
      
      # Determine what PR(s) to review
      - name: Determine PRs to review
        id: determine-prs
        run: |
          # Check if review_all was specified
          if [[ "${{ github.event.inputs.review_all }}" == "true" ]]; then
            echo "REVIEW_ALL=true" >> $GITHUB_ENV
            # Get all open PRs
            gh pr list --state open --json number --jq '.[].number' > prs_to_review.txt
            PR_COUNT=$(cat prs_to_review.txt | wc -l)
            echo "PR_COUNT=$PR_COUNT" >> $GITHUB_ENV
            echo "Will review $PR_COUNT open PRs"
          elif [[ -n "${{ github.event.inputs.pr_number }}" ]]; then
            # Review specific PR
            echo "${{ github.event.inputs.pr_number }}" > prs_to_review.txt
            echo "PR_COUNT=1" >> $GITHUB_ENV
            echo "Will review PR #${{ github.event.inputs.pr_number }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Review current PR
            echo "${{ github.event.pull_request.number }}" > prs_to_review.txt
            echo "PR_COUNT=1" >> $GITHUB_ENV
            echo "Will review PR #${{ github.event.pull_request.number }}"
          else
            echo "No PRs to review"
            echo "PR_COUNT=0" >> $GITHUB_ENV
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Review each PR
      - name: Review PRs
        if: env.PR_COUNT > 0
        run: |
          # Create Python script to review PR
          cat > review_pr.py << 'EOF'
          import json
          import os
          import re
          import sys
          import subprocess
          from pathlib import Path
          from openai import OpenAI

          client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

          def get_pr_details(pr_number):
              """Get details about a PR using GitHub CLI"""
              try:
                  result = subprocess.run(
                      ["gh", "pr", "view", str(pr_number), "--json", "number,title,body,files,additions,deletions,changedFiles,commits"],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  return json.loads(result.stdout)
              except subprocess.CalledProcessError as e:
                  print(f"Error getting PR details: {e.stderr}")
                  return None

          def get_file_content(file_path, pr_number):
              """Get the content of a file in a PR"""
              try:
                  result = subprocess.run(
                      ["gh", "pr", "view", str(pr_number), "--file", file_path],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  return result.stdout
              except subprocess.CalledProcessError as e:
                  print(f"Error getting file content: {e.stderr}")
                  return None

          def get_diff(file_path, pr_number):
              """Get the diff of a file in a PR"""
              try:
                  # Use git diff (from origin/HEAD to current) if possible
                  pr_details = get_pr_details(pr_number)
                  if pr_details and "commits" in pr_details and pr_details["commits"]:
                      base_ref = pr_details.get("baseRefName", "main")
                      # Get diff using git cli
                      result = subprocess.run(
                          ["git", "diff", f"origin/{base_ref}..HEAD", "--", file_path],
                          capture_output=True,
                          text=True
                      )
                      if result.returncode == 0 and result.stdout:
                          return result.stdout
                  
                  # Fallback to GitHub CLI
                  result = subprocess.run(
                      ["gh", "pr", "diff", str(pr_number), "--name-only"],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  return result.stdout
              except subprocess.CalledProcessError as e:
                  print(f"Error getting diff: {e.stderr}")
                  return None

          def identify_code_smells(file_content, file_path):
              """Identify code smells in a file"""
              smells = []
              
              # Check file extension
              ext = Path(file_path).suffix.lower()
              
              if ext == ".py":
                  # Python-specific checks
                  
                  # Check for long functions
                  function_pattern = r"def\s+(\w+)\s*\("
                  functions = re.finditer(function_pattern, file_content)
                  for match in functions:
                      func_name = match.group(1)
                      func_start = match.start()
                      # Find the next function definition or end of file
                      next_func = re.search(function_pattern, file_content[func_start + 1:])
                      func_end = next_func.start() + func_start + 1 if next_func else len(file_content)
                      func_content = file_content[func_start:func_end]
                      # Count lines
                      line_count = func_content.count('\n')
                      if line_count > 30:
                          smells.append({
                              "type": "long_function",
                              "line": file_content[:func_start].count('\n') + 1,
                              "description": f"Function '{func_name}' is {line_count} lines long"
                          })
                  
                  # Check for commented-out code
                  commented_code_pattern = r"^\s*# .*(.* = .*|def |class |if |for |while |return |import |from ).{20,}$"
                  commented_code = re.finditer(commented_code_pattern, file_content, re.MULTILINE)
                  for match in commented_code:
                      line_number = file_content[:match.start()].count('\n') + 1
                      smells.append({
                          "type": "commented_code",
                          "line": line_number,
                          "description": "Commented-out code detected"
                      })
              
              elif ext in [".js", ".jsx", ".ts", ".tsx"]:
                  # JavaScript/TypeScript-specific checks
                  
                  # Check for console.log statements
                  console_pattern = r"console\.(log|warn|error|info)\("
                  console_calls = re.finditer(console_pattern, file_content)
                  for match in console_calls:
                      line_number = file_content[:match.start()].count('\n') + 1
                      smells.append({
                          "type": "console_statement",
                          "line": line_number,
                          "description": f"Console statement detected: {match.group(0)}"
                      })
              
              # Check for TODO/FIXME comments across all languages
              todo_pattern = r"(?:^|\s)(?:#|//) ?(?:TODO|FIXME):? ?(.*?)$"
              todos = re.finditer(todo_pattern, file_content, re.MULTILINE | re.IGNORECASE)
              for match in todos:
                  line_number = file_content[:match.start()].count('\n') + 1
                  smells.append({
                      "type": "todo",
                      "line": line_number,
                      "description": f"TODO/FIXME comment: {match.group(1)}"
                  })
              
              return smells

          def analyze_complexity(file_content, file_path):
              """Analyze code complexity"""
              complexity = {
                  "cognitive_complexity": 0,
                  "too_many_branches": False,
                  "deep_nesting": False,
                  "complex_expressions": 0
              }
              
              # Check file extension
              ext = Path(file_path).suffix.lower()
              
              if ext == ".py":
                  # Count if/elif/else statements
                  if_count = len(re.findall(r"\bif\b", file_content))
                  elif_count = len(re.findall(r"\belif\b", file_content))
                  else_count = len(re.findall(r"\belse\b", file_content))
                  branches = if_count + elif_count + else_count
                  complexity["cognitive_complexity"] = branches
                  complexity["too_many_branches"] = branches > 15
                  
                  # Check for nested conditions
                  nested_pattern = r"if.*:\s*\n\s{4,}if"
                  nested_count = len(re.findall(nested_pattern, file_content))
                  complexity["deep_nesting"] = nested_count > 2
                  
                  # Check for complex expressions
                  complex_expr_pattern = r"if.*and.*and|if.*or.*or|if.*and.*or.*and"
                  complex_expr_count = len(re.findall(complex_expr_pattern, file_content))
                  complexity["complex_expressions"] = complex_expr_count
              
              elif ext in [".js", ".jsx", ".ts", ".tsx"]:
                  # Count if/else statements
                  if_count = len(re.findall(r"\bif\s*\(", file_content))
                  else_if_count = len(re.findall(r"\belse\s+if\s*\(", file_content))
                  else_count = len(re.findall(r"\belse\b", file_content))
                  branches = if_count + else_if_count + else_count
                  complexity["cognitive_complexity"] = branches
                  complexity["too_many_branches"] = branches > 15
                  
                  # Check for nested conditions
                  nested_pattern = r"if\s*\(.*\)\s*\{[\s\S]{0,30}if\s*\("
                  nested_count = len(re.findall(nested_pattern, file_content))
                  complexity["deep_nesting"] = nested_count > 2
                  
                  # Check for complex expressions
                  complex_expr_pattern = r"if\s*\(.*&&.*&&|if\s*\(.*\|\|.*\|\||if\s*\(.*&&.*\|\|.*&&"
                  complex_expr_count = len(re.findall(complex_expr_pattern, file_content))
                  complexity["complex_expressions"] = complex_expr_count
              
              return complexity

          def analyze_pr(pr_number):
              """Analyze a PR and generate a review"""
              pr_details = get_pr_details(pr_number)
              if not pr_details:
                  print(f"Failed to get details for PR #{pr_number}")
                  return None
              
              # Build context about the PR
              context = {
                  "title": pr_details.get("title", ""),
                  "body": pr_details.get("body", ""),
                  "additions": pr_details.get("additions", 0),
                  "deletions": pr_details.get("deletions", 0),
                  "changed_files": pr_details.get("changedFiles", 0),
                  "files": [],
                  "summary": {
                      "code_quality_issues": 0,
                      "security_issues": 0,
                      "performance_issues": 0,
                      "maintainability_issues": 0,
                      "test_coverage": "unknown"
                  }
              }
              
              # Process each file
              files = pr_details.get("files", [])
              for file in files:
                  file_path = file.get("path", "")
                  status = file.get("status", "")
                  
                  # Skip deleted files
                  if status == "deleted":
                      context["files"].append({
                          "path": file_path,
                          "status": status
                      })
                      continue
                  
                  # Get file content
                  content = get_file_content(file_path, pr_number)
                  if content is None:
                      continue
                  
                  # Get diff
                  diff = get_diff(file_path, pr_number)
                  
                  # Analyze file
                  code_smells = identify_code_smells(content, file_path)
                  complexity = analyze_complexity(content, file_path)
                  
                  # Update summary
                  if code_smells:
                      context["summary"]["code_quality_issues"] += len([s for s in code_smells if s["type"] in ["commented_code", "console_statement"]])
                      context["summary"]["maintainability_issues"] += len([s for s in code_smells if s["type"] in ["long_function", "todo"]])
                  
                  if complexity["too_many_branches"] or complexity["deep_nesting"]:
                      context["summary"]["maintainability_issues"] += 1
                  
                  if complexity["complex_expressions"] > 0:
                      context["summary"]["performance_issues"] += complexity["complex_expressions"]
                  
                  # Add file analysis to context
                  context["files"].append({
                      "path": file_path,
                      "status": status,
                      "code_smells": code_smells,
                      "complexity": complexity,
                      "diff_snippet": diff[:1000] if diff else "",  # First 1000 chars of diff
                      "content_preview": content[:5000] if content else ""  # First 5000 chars of content
                  })
              
              return context

          def generate_review(pr_context):
              """Generate a PR review using AI"""
              # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
              # do not change this unless explicitly requested by the user
              
              # Create system message
              system_content = """You are an experienced software engineer conducting a thorough code review.

              Your task is to:
              1. Identify potential bugs, code smells, security issues, and performance problems
              2. Suggest improvements to code quality, maintainability, and readability
              3. Highlight good coding practices that you observe
              4. Provide clear, actionable feedback with code examples where appropriate
              
              Your review should be thorough but constructive. Focus on helping the developer improve rather than just criticizing.
              Use markdown formatting in your response, including code blocks with language specifiers.
              
              Structure your review as follows:
              
              1. Summary - A brief overview of the changes and your overall impression
              2. Strengths - What was done well
              3. Areas for Improvement - Issues that should be addressed, with specific code references
              4. Suggestions - Concrete recommendations with examples where possible
              5. Questions - Any clarifications needed about the implementation
              
              Be respectful and professional in your tone."""
              
              # Create user message with PR context
              user_content = f"""
              # Pull Request Review
              
              I need your help reviewing this Pull Request:
              
              ## PR Details
              
              **Title:** {pr_context['title']}
              
              **Description:**
              {pr_context['body']}
              
              **Changes:**
              - {pr_context['additions']} additions
              - {pr_context['deletions']} deletions
              - {pr_context['changed_files']} files changed
              
              ## Files Changed
              
              """
              
              # Add details about each file
              for i, file in enumerate(pr_context['files']):
                  file_type = Path(file['path']).suffix.lower()[1:] if Path(file['path']).suffix else "text"
                  
                  user_content += f"### {i+1}. `{file['path']}` ({file['status']})\n\n"
                  
                  if file['status'] == "deleted":
                      user_content += "File was deleted.\n\n"
                      continue
                  
                  if "code_smells" in file and file["code_smells"]:
                      user_content += "**Code Smells:**\n"
                      for smell in file["code_smells"]:
                          user_content += f"- Line {smell['line']}: {smell['description']}\n"
                      user_content += "\n"
                  
                  if "complexity" in file:
                      complexity = file["complexity"]
                      user_content += "**Complexity Analysis:**\n"
                      user_content += f"- Cognitive Complexity: {complexity['cognitive_complexity']}\n"
                      if complexity['too_many_branches']:
                          user_content += f"- Too many branches detected\n"
                      if complexity['deep_nesting']:
                          user_content += f"- Deep nesting detected\n"
                      if complexity['complex_expressions'] > 0:
                          user_content += f"- Complex expressions: {complexity['complex_expressions']}\n"
                      user_content += "\n"
                  
                  if "diff_snippet" in file and file["diff_snippet"]:
                      user_content += "**Diff Snippet:**\n"
                      user_content += f"```{file_type}\n{file['diff_snippet']}\n```\n\n"
                  
                  if "content_preview" in file and file["content_preview"]:
                      user_content += "**File Content Preview:**\n"
                      user_content += f"```{file_type}\n{file['content_preview'][:1000]}...\n```\n\n"
                  
                  # Limit the content to avoid hitting token limits
                  if i >= 4 and len(pr_context['files']) > 5:
                      remaining = len(pr_context['files']) - i - 1
                      user_content += f"\n... and {remaining} more files (omitted for brevity)\n"
                      break
              
              # Add summary section
              user_content += """
              ## Review Focus Areas
              
              Please focus on:
              1. Code correctness and potential bugs
              2. Code maintainability and readability
              3. Performance considerations
              4. Security concerns
              5. Adherence to best practices
              
              Provide specific, actionable feedback with code examples where appropriate.
              """
              
              try:
                  response = client.chat.completions.create(
                      model="gpt-4o",
                      messages=[
                          {"role": "system", "content": system_content},
                          {"role": "user", "content": user_content}
                      ],
                      temperature=0.2,
                      max_tokens=4096
                  )
                  
                  return response.choices[0].message.content
              except Exception as e:
                  print(f"Error generating review: {str(e)}")
                  return f"""
                  # Error Generating Review
                  
                  I encountered an error while trying to generate a detailed review for this PR:
                  
                  ```
                  {str(e)}
                  ```
                  
                  ## Summary of Changes
                  
                  - {pr_context['additions']} additions
                  - {pr_context['deletions']} deletions
                  - {pr_context['changed_files']} files changed
                  
                  Please review the changes manually or try again later.
                  """

          def submit_review(pr_number, review_content):
              """Submit a review for a PR using GitHub CLI"""
              try:
                  # Create a temporary file for the review content
                  with open("review.md", "w") as f:
                      f.write(review_content)
                  
                  # Submit the review
                  result = subprocess.run(
                      ["gh", "pr", "review", str(pr_number), "--body-file", "review.md", "--comment"],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  
                  print(f"Review submitted for PR #{pr_number}")
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"Error submitting review: {e.stderr}")
                  return False

          if __name__ == "__main__":
              if len(sys.argv) < 2:
                  print("Please provide a PR number")
                  sys.exit(1)
              
              pr_number = sys.argv[1]
              print(f"Analyzing PR #{pr_number}...")
              
              # Analyze PR
              pr_context = analyze_pr(pr_number)
              if not pr_context:
                  sys.exit(1)
              
              # Generate review
              print(f"Generating review for PR #{pr_number}...")
              review_content = generate_review(pr_context)
              
              # Submit review
              print(f"Submitting review for PR #{pr_number}...")
              success = submit_review(pr_number, review_content)
              
              sys.exit(0 if success else 1)
          EOF
          
          # Process each PR
          while read -r PR_NUMBER; do
            echo "Reviewing PR #$PR_NUMBER..."
            python review_pr.py "$PR_NUMBER"
            
            # Add a short delay between reviews to avoid rate limits
            if [[ "${{ env.REVIEW_ALL }}" == "true" ]]; then
              sleep 5
            fi
          done < prs_to_review.txt
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}