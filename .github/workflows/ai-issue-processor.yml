name: AI Issue Processor

on:
  issues:
    types: [opened, edited, labeled]
  issue_comment:
    types: [created, edited]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number
      action_type:
        description: 'Type of action to perform'
        required: true
        type: choice
        options:
          - analyze
          - suggest-fix
          - implement
          - optimize

jobs:
  process-issue:
    name: Process Issue with AI
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      # Determine issue to process
      - name: Set issue number
        id: set-issue
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "ISSUE_NUMBER=${{ github.event.inputs.issue_number }}" >> $GITHUB_ENV
          else
            echo "ISSUE_NUMBER=${{ github.event.issue.number }}" >> $GITHUB_ENV
          fi
      
      # Get issue details
      - name: Get issue details
        id: get-issue
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ISSUE_JSON=$(gh api repos/${{ github.repository }}/issues/${{ env.ISSUE_NUMBER }})
            echo "ISSUE_TITLE=$(echo $ISSUE_JSON | jq -r '.title')" >> $GITHUB_ENV
            echo "ISSUE_BODY=$(echo $ISSUE_JSON | jq -r '.body')" >> $GITHUB_ENV
            echo "ISSUE_LABELS=$(echo $ISSUE_JSON | jq -r '.labels[].name')" >> $GITHUB_ENV
          else
            echo "ISSUE_TITLE=${{ github.event.issue.title }}" >> $GITHUB_ENV
            echo "ISSUE_BODY=${{ github.event.issue.body }}" >> $GITHUB_ENV
            
            # Get labels as comma-separated list
            LABELS=$(gh api repos/${{ github.repository }}/issues/${{ env.ISSUE_NUMBER }} | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
            echo "ISSUE_LABELS=$LABELS" >> $GITHUB_ENV
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Check if this is an AI command comment
      - name: Check for AI command
        id: check-command
        if: github.event_name == 'issue_comment'
        run: |
          COMMENT="${{ github.event.comment.body }}"
          if [[ "$COMMENT" =~ "@ai "* ]]; then
            COMMAND=$(echo "$COMMENT" | grep -o '@ai [a-z\-]*' | sed 's/@ai //')
            echo "AI_COMMAND=$COMMAND" >> $GITHUB_ENV
            echo "HAS_COMMAND=true" >> $GITHUB_ENV
            
            # Extract the rest as instructions
            INSTRUCTIONS=$(echo "$COMMENT" | sed 's/@ai [a-z\-]* //')
            echo "AI_INSTRUCTIONS=$INSTRUCTIONS" >> $GITHUB_ENV
          else
            echo "HAS_COMMAND=false" >> $GITHUB_ENV
          fi
      
      # Determine action type
      - name: Set action type
        id: set-action
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "ACTION_TYPE=${{ github.event.inputs.action_type }}" >> $GITHUB_ENV
          elif [ "${{ env.HAS_COMMAND }}" == "true" ]; then
            echo "ACTION_TYPE=${{ env.AI_COMMAND }}" >> $GITHUB_ENV
          else
            # Default based on issue labels
            if [[ "${{ env.ISSUE_LABELS }}" == *"bug"* ]]; then
              echo "ACTION_TYPE=suggest-fix" >> $GITHUB_ENV
            elif [[ "${{ env.ISSUE_LABELS }}" == *"enhancement"* ]]; then
              echo "ACTION_TYPE=analyze" >> $GITHUB_ENV
            else
              echo "ACTION_TYPE=analyze" >> $GITHUB_ENV
            fi
          fi
      
      # Create a unique branch for this issue
      - name: Create branch
        run: |
          BRANCH_NAME="ai-issue-${{ env.ISSUE_NUMBER }}"
          git checkout -b $BRANCH_NAME
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
      
      # Process with AI based on action type
      - name: Process with OpenAI
        id: openai
        run: |
          # Set up Python environment
          pip install openai
          
          ACTION="${{ env.ACTION_TYPE }}"
          TITLE="${{ env.ISSUE_TITLE }}"
          BODY="${{ env.ISSUE_BODY }}"
          
          # Create a Python script to call OpenAI API
          cat > process_issue.py << 'EOF'
          import json
          import os
          import sys
          from openai import OpenAI

          client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

          def process_issue(action_type, title, body, repo_files=None):
              # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
              # do not change this unless explicitly requested by the user
              
              # Create system prompt based on action type
              if action_type == "analyze":
                  system_content = "You are an AI assistant specialized in analyzing GitHub issues. Provide a thorough analysis of the issue and suggest potential approaches."
              elif action_type == "suggest-fix":
                  system_content = "You are an AI assistant specialized in debugging code. Analyze the bug described in the issue and suggest specific code changes to fix it."
              elif action_type == "implement":
                  system_content = "You are an AI assistant specialized in implementing features. Design and implement the feature described in the issue with specific code changes."
              elif action_type == "optimize":
                  system_content = "You are an AI assistant specialized in optimizing code. Analyze the performance issues described and suggest specific optimizations."
              else:
                  system_content = "You are an AI assistant specialized in analyzing GitHub issues and suggesting code changes."
              
              # Create context about the repository
              repo_context = ""
              if repo_files:
                  repo_context = "The repository contains the following files:\n" + "\n".join(repo_files)
              
              # Build the user message
              user_content = f"""
              ## Action Requested: {action_type.upper()}
              
              ## Issue Title: 
              {title}
              
              ## Issue Description:
              {body}
              
              {repo_context}
              
              Please {action_type} this issue and provide your response in JSON format with the following structure:
              
              {{
                "analysis": "Your detailed analysis of the issue",
                "suggestions": ["Suggestion 1", "Suggestion 2", ...],
                "fix": "Detailed description of the fix (for suggest-fix)",
                "implementation": "Implementation details (for implement)",
                "optimization": "Optimization approach (for optimize)",
                "code_changes": [
                  {{
                    "file": "path/to/file.py",
                    "change": "The exact code to be added or modified"
                  }},
                  ...
                ]
              }}
              
              Ensure that your response is valid JSON and includes all relevant fields.
              """
              
              # Call the OpenAI API
              try:
                  response = client.chat.completions.create(
                      model="gpt-4o",
                      messages=[
                          {"role": "system", "content": system_content},
                          {"role": "user", "content": user_content}
                      ],
                      temperature=0.7,
                      response_format={"type": "json_object"}
                  )
                  
                  # Parse the JSON response
                  result = json.loads(response.choices[0].message.content)
                  return result
              except Exception as e:
                  return {
                      "analysis": f"Error processing issue: {str(e)}",
                      "suggestions": ["Try again with more detailed information."],
                      "error": str(e)
                  }

          if __name__ == "__main__":
              action = sys.argv[1]
              title = sys.argv[2]
              body = sys.argv[3]
              
              # Get list of repository files (could be expanded to include file contents)
              repo_files = []
              for root, dirs, files in os.walk('.'):
                  for file in files:
                      if not root.startswith('./.git') and not file.endswith('.pyc'):
                          repo_files.append(os.path.join(root, file))
              
              result = process_issue(action, title, body, repo_files[:50])  # Limit to first 50 files for context
              
              # Output the result as JSON
              print(json.dumps(result, indent=2))
              
              # Also write to a file
              with open('ai_response.json', 'w') as f:
                  json.dump(result, f, indent=2)
          EOF
          
          # Make the script executable
          chmod +x process_issue.py
          
          # Run the Python script
          python process_issue.py "$ACTION" "$TITLE" "$BODY" > ai_response.json
          
          echo "AI_RESPONSE_FILE=ai_response.json" >> $GITHUB_ENV
          
          # Comment the analysis on the issue
          jq -r '.analysis' ai_response.json | gh issue comment ${{ env.ISSUE_NUMBER }} --body-file -
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        continue-on-error: true
      
      # Create a summary file
      - name: Create AI summary
        run: |
          mkdir -p .github/ai-changes
          
          cat > .github/ai-changes/SUMMARY.md << EOL
          # AI-Generated Changes for Issue #${{ env.ISSUE_NUMBER }}
          
          ## Issue Details
          
          **Title:** ${{ env.ISSUE_TITLE }}
          
          ## AI Analysis
          
          $(jq -r '.analysis' ${{ env.AI_RESPONSE_FILE }})
          
          ## Proposed Changes
          
          $(jq -r '.suggestions // .fix // .implementation // .optimization // "No specific changes proposed"' ${{ env.AI_RESPONSE_FILE }})
          
          ## Code Changes
          
          The following files would be modified:
          
          $(jq -r '.code_changes[] | "- `" + .file + "`"' ${{ env.AI_RESPONSE_FILE }} 2>/dev/null || echo "- No code changes specified")
          
          ---
          
          Generated by AI Assistant
          EOL
          
          git add .github/ai-changes/SUMMARY.md
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub AI Assistant"
          git commit -m "docs: Add AI analysis summary for issue #${{ env.ISSUE_NUMBER }}"
      
      # Apply the changes if action type is implement, suggest-fix, or optimize
      - name: Apply AI suggested changes
        if: env.ACTION_TYPE == 'implement' || env.ACTION_TYPE == 'suggest-fix' || env.ACTION_TYPE == 'optimize'
        run: |
          # Create a Python script to apply the changes
          cat > apply_changes.py << 'EOF'
          import json
          import os
          import sys

          def apply_changes(response_file):
              try:
                  # Load the AI response
                  with open(response_file, 'r') as f:
                      response = json.load(f)
                  
                  # Check if there are code changes to apply
                  if 'code_changes' not in response or not response['code_changes']:
                      print("No code changes to apply")
                      return False
                  
                  changes_applied = 0
                  
                  # Apply each code change
                  for change in response['code_changes']:
                      if 'file' not in change or 'change' not in change:
                          print(f"Invalid change format: {change}")
                          continue
                      
                      file_path = change['file']
                      code_content = change['change']
                      
                      # Make sure the directory exists
                      os.makedirs(os.path.dirname(file_path) or '.', exist_ok=True)
                      
                      # Check if we're modifying an existing file or creating a new one
                      if os.path.exists(file_path):
                          print(f"Modifying existing file: {file_path}")
                          
                          # Read existing content
                          with open(file_path, 'r') as f:
                              existing_content = f.read()
                          
                          # Handle replacements if specified in the change
                          if 'replace' in change and change['replace']:
                              if 'pattern' in change and 'with' in change:
                                  # Replace specific pattern
                                  modified_content = existing_content.replace(change['pattern'], change['with'])
                              else:
                                  # Replace entire file
                                  modified_content = code_content
                          else:
                              # Append to file by default
                              modified_content = existing_content + "\n\n" + code_content
                          
                          # Write back the modified content
                          with open(file_path, 'w') as f:
                              f.write(modified_content)
                      else:
                          print(f"Creating new file: {file_path}")
                          
                          # Create new file with the content
                          with open(file_path, 'w') as f:
                              f.write(code_content)
                      
                      changes_applied += 1
                  
                  print(f"Applied {changes_applied} code changes")
                  return True
              except Exception as e:
                  print(f"Error applying changes: {str(e)}")
                  return False

          if __name__ == "__main__":
              if len(sys.argv) < 2:
                  print("Usage: python apply_changes.py <response_file>")
                  sys.exit(1)
              
              response_file = sys.argv[1]
              success = apply_changes(response_file)
              
              if not success:
                  # Create a fallback file with explanation
                  os.makedirs('ai_changes', exist_ok=True)
                  with open('ai_changes/IMPLEMENTATION.md', 'w') as f:
                      try:
                          with open(response_file, 'r') as rf:
                              response = json.load(rf)
                          
                          f.write("# AI Implementation Notes\n\n")
                          f.write("## Analysis\n\n")
                          f.write(response.get('analysis', 'No analysis provided') + "\n\n")
                          
                          f.write("## Implementation Details\n\n")
                          f.write(response.get('implementation', response.get('fix', response.get('optimization', 'No implementation details provided'))) + "\n\n")
                          
                          f.write("## Code Changes\n\n")
                          f.write("```python\n")
                          for change in response.get('code_changes', []):
                              f.write(f"# File: {change.get('file', 'unknown')}\n")
                              f.write(change.get('change', '# No changes specified') + "\n\n")
                          f.write("```\n")
                      except Exception as e:
                          f.write(f"# Error creating implementation notes: {str(e)}")
          EOF
          
          # Make the script executable
          chmod +x apply_changes.py
          
          # Run the Python script to apply changes
          python apply_changes.py "${{ env.AI_RESPONSE_FILE }}"
          
          # Add all changes to git
          git add .
          git commit -m "feat: Apply AI-suggested changes for issue #${{ env.ISSUE_NUMBER }}"
      
      # Push changes to the branch
      - name: Push changes
        run: git push origin ${{ env.BRANCH_NAME }}
      
      # Create pull request
      - name: Create Pull Request
        run: |
          ACTION_NAME="${{ env.ACTION_TYPE }}"
          
          # Capitalize first letter for title
          ACTION_NAME_CAPITALIZED=$(echo "$ACTION_NAME" | sed 's/^\(.\)/\U\1/')
          
          # Create PR with appropriate title and body based on action type
          PR_BODY="This pull request was automatically generated by the AI assistant in response to issue #${{ env.ISSUE_NUMBER }}.

          ## AI $ACTION_NAME_CAPITALIZED
          
          $(jq -r '.analysis' ${{ env.AI_RESPONSE_FILE }})
          
          ## Changes Included
          
          $(jq -r '.suggestions // .fix // .implementation // .optimization // "No specific changes described"' ${{ env.AI_RESPONSE_FILE }})
          
          ## Implementation Details
          
          $(jq -r '.code_changes[] | "- `" + .file + "`: " + (.change | split("\n") | first)' ${{ env.AI_RESPONSE_FILE }} 2>/dev/null || echo "- Implementation details not available")
          
          ---
          
          To provide feedback on these changes, please comment on this PR or the original issue.
          To request further adjustments, add a comment with \`@ai adjust [your instructions]\`.
          
          Closes #${{ env.ISSUE_NUMBER }}"
          
          # Create the PR
          gh pr create --title "[$ACTION_NAME_CAPITALIZED] ${{ env.ISSUE_TITLE }}" \
                      --body "$PR_BODY" \
                      --base main \
                      --head ${{ env.BRANCH_NAME }} \
                      --label "ai-generated"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}